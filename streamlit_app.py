"""
streamlit_app.py
=================

Prototype analytics web application for visualizing results of differentially
private experiments.  This Streamlit app reads JSON reports generated by the
`dp_pipeline` unified experiment framework and displays key metrics across
experiments.  The interface allows filtering by experiment name, method,
clipping norm, noise multiplier, and other hyper‑parameters, and renders
interactive charts summarizing accuracy and loss.

Usage
-----
To run the app locally, first ensure that Streamlit is installed:

    pip install streamlit pandas

Then launch the app from the command line:

    streamlit run streamlit_app.py

The app will search for result files in the `dp_experiment_outputs` directory
relative to the current working directory.  If you choose a different
location, set the `RESULTS_DIR` variable accordingly.
"""

from __future__ import annotations

import json
import os
from typing import List, Dict, Any

import pandas as pd  # type: ignore
import streamlit as st  # type: ignore

# Directory containing JSON result files.  Modify this path as needed.
RESULTS_DIR = os.path.join(os.path.dirname(__file__), "dp_experiment_outputs")


def load_results(directory: str) -> List[Dict[str, Any]]:
    """Load all JSON result files from a directory.

    Args:
        directory: Path to a directory containing JSON reports.

    Returns:
        A list of dictionaries with merged top‑level and nested fields.
    """
    records: List[Dict[str, Any]] = []
    for filename in os.listdir(directory):
        if not filename.endswith(".json"):
            continue
        path = os.path.join(directory, filename)
        try:
            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception as e:
            print(f"Failed to load {filename}: {e}")
            continue
        # Flatten nested structures for DataFrame convenience
        record: Dict[str, Any] = {
            "experiment_name": data.get("experiment_name"),
            "dataset": data.get("dataset"),
            "model": data.get("model"),
            "method": data.get("method"),
            "timestamp": data.get("timestamp"),
            "comments": data.get("comments"),
        }
        hyperparams = data.get("hyperparameters", {})
        privacy = data.get("privacy", {})
        metrics = data.get("metrics", {})
        # Merge dictionaries with prefix to avoid key collisions
        for k, v in hyperparams.items():
            record[f"hp_{k}"] = v
        for k, v in privacy.items():
            record[f"priv_{k}"] = v
        for k, v in metrics.items():
            record[f"metric_{k}"] = v
        records.append(record)
    return records


def main() -> None:
    st.title("Differentially Private ML Experiment Dashboard")
    st.markdown(
        "This dashboard visualizes results from various DP experiments. "
        "Use the sidebar to filter experiments and choose which metrics to display."
    )

    # Load results
    if not os.path.exists(RESULTS_DIR):
        st.error(f"Results directory not found: {RESULTS_DIR}")
        return
    records = load_results(RESULTS_DIR)
    if not records:
        st.warning(
            "No result files were found. Please generate experiments and place "
            "their JSON outputs in the dp_experiment_outputs directory."
        )
        return

    df = pd.DataFrame(records)

    # Sidebar filters
    st.sidebar.header("Filters")
    methods = sorted(df["method"].dropna().unique())
    selected_methods = st.sidebar.multiselect(
        "Method", methods, default=methods
    )
    df_filtered = df[df["method"].isin(selected_methods)]

    # Filter by experiment name substring
    exp_substring = st.sidebar.text_input(
        "Experiment name contains", value="", help="Leave blank to include all experiments."
    )
    if exp_substring:
        df_filtered = df_filtered[df_filtered["experiment_name"].str.contains(exp_substring, case=False)]

    # Choose metric to plot
    metric_columns = [c for c in df.columns if c.startswith("metric_")]
    if not metric_columns:
        st.error("No metric columns found in results.")
        return
    selected_metric = st.sidebar.selectbox(
        "Metric to plot", metric_columns, index=metric_columns.index("metric_test_accuracy_final") if "metric_test_accuracy_final" in metric_columns else 0
    )

    # Display table of results
    st.subheader("Filtered Results")
    st.dataframe(df_filtered)

    # Plot metric across experiments
    st.subheader(f"{selected_metric} across experiments")
    if not df_filtered.empty:
        chart_data = df_filtered[["experiment_name", selected_metric]].set_index("experiment_name")
        st.bar_chart(chart_data)
    else:
        st.info("No experiments match the current filters.")


if __name__ == "__main__":
    main()